{"version":3,"file":"L.AutoGraticule.js","sources":["../src/L.AutoGraticule.ts"],"sourcesContent":["import { LatLngBounds, LatLngExpression, LayerOptions, LeafletEventHandlerFnMap, PolylineOptions, Map, LayerGroup, Util, Polyline, LatLng, marker, divIcon, latLngBounds } from 'leaflet';\nimport './L.AutoGraticule.css';\n\nexport interface AutoGraticuleOptions extends LayerOptions {\n    redraw: keyof LeafletEventHandlerFnMap,\n\n    /** Minimum distance between two lines in pixels */\n    minDistance: number\n}\n\nexport default class AutoGraticule extends LayerGroup {\n\n    options: AutoGraticuleOptions = {\n        redraw: 'moveend',\n        minDistance: 100 // Minimum distance between two lines in pixels\n    };\n\n    lineStyle: PolylineOptions = {\n        stroke: true,\n        color: '#111',\n        opacity: 0.6,\n        weight: 1,\n        interactive: false\n    };\n\n    _bounds!: LatLngBounds;\n\n\n    constructor(options?: Partial<AutoGraticuleOptions>) {\n        super();\n        Util.setOptions(this, options);\n    }\n\n\n    onAdd(map: Map) {\n        this._map = map;\n\n        this.redraw();\n        this._map.on('viewreset ' + this.options.redraw, this.redraw, this);\n\n        this.eachLayer(map.addLayer, map);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        map.off('viewreset '+ this.options.redraw, this.redraw, this);\n        this.eachLayer(this.removeLayer, this);\n        return this;\n    }\n\n    redraw() {\n        this._bounds = this._map.getBounds().pad(0.5);\n\n        this.clearLayers();\n\n        this.constructLines();\n\n        return this;\n    }\n\n    constructLines() {\n        const bounds = this._map.getBounds();\n        const zoom = this._map.getZoom();\n\n        // Fix drawing of lines outside of bounds\n        this._bounds = AutoGraticule.bboxIntersect(bounds, [[-85, -180], [85, 180]]);\n\n        // Fix drawing of labels outside of bounds\n        const getBoundsBkp = this._map.getBounds;\n        try {\n            this._map.getBounds = function() {\n                return AutoGraticule.bboxIntersect(getBoundsBkp.apply(this), [[-85, -180], [85, 180]])\n            };\n\n            // Longitude: Draw vartical lines with a fixed distance between each other\n            const center = this._map.project(bounds.getCenter(), zoom);\n            const divisor = AutoGraticule.getGridDivisor(this._map.unproject(center.add([ this.options.minDistance / 2, 0 ]), zoom).lng - this._map.unproject(center.subtract([ this.options.minDistance / 2, 0 ]), zoom).lng, false);\n            const west = Math.max(bounds.getWest(), -180);\n            const east = Math.min(bounds.getEast(), 180);\n            for (let lng = AutoGraticule.fixFloatingPoint(Math.ceil(west/divisor)*divisor); lng <= east; lng+=divisor) {\n                this.addLayer(this.buildXLine(lng));\n                this.addLayer(this.buildLabel('gridlabel-horiz', AutoGraticule.fixFloatingPoint(lng)));\n            }\n\n            // Latitude: Draw horizontal lines with a variable distance between each other (as in Mercator projection, the distance\n            // between latitudes gets bigger towards the poles). Calculate a divisor that all latitude line coordinates must be\n            // dividable by, but then only draw those coordinates that keep the minimum distance to their neighbour lines.\n            // Draw lines north of the equator separately from lines south of the equator (to keep the grid symmetical in\n            // relation to the equator).\n            if(bounds.getNorth() > 0) {\n                let lat = Math.max(0, bounds.getSouth());\n                let first = true;\n                while(lat < bounds.getNorth() && lat < 85) {\n                    const point = this._map.project([ lat, bounds.getCenter().lng ], zoom);\n                    const point2LatLng = this._map.unproject(point.subtract([ 0, this.options.minDistance ]), zoom);\n\n                    const divisor = AutoGraticule.getGridDivisor(point2LatLng.lat - lat, true);\n                    lat = AutoGraticule.fixFloatingPoint(first ? Math.ceil(lat/divisor)*divisor : Math.ceil(point2LatLng.lat/divisor)*divisor);\n\n                    first = false;\n\n                    this.addLayer(this.buildYLine(lat));\n                    this.addLayer(this.buildLabel('gridlabel-vert', lat));\n                }\n            }\n            if(bounds.getSouth() < 0) {\n                let lat = Math.min(0, bounds.getNorth());\n                let first = true;\n                while(lat > bounds.getSouth() && lat > -85) {\n                    const point = this._map.project([ lat, bounds.getCenter().lng ], zoom);\n                    const point2LatLng = this._map.unproject(point.add([ 0, this.options.minDistance ]), zoom);\n\n                    const divisor = AutoGraticule.getGridDivisor(AutoGraticule.fixFloatingPoint(lat - point2LatLng.lat), true);\n                    lat = AutoGraticule.fixFloatingPoint(first ? Math.floor(lat/divisor)*divisor : Math.floor(point2LatLng.lat/divisor)*divisor);\n\n                    first = false;\n\n                    this.addLayer(this.buildYLine(lat));\n                    this.addLayer(this.buildLabel('gridlabel-vert', lat));\n                }\n            }\n        } finally {\n            this._map.getBounds = getBoundsBkp;\n        }\n    }\n\n    buildXLine(x: number): Polyline {\n        const bottomLL = new LatLng(this._bounds.getSouth(), x);\n        const topLL = new LatLng(this._bounds.getNorth(), x);\n\n        return new Polyline([bottomLL, topLL], this.lineStyle);\n    }\n\n    buildYLine(y: number): L.Polyline {\n        const leftLL = new LatLng(y, this._bounds.getWest());\n        const rightLL = new LatLng(y, this._bounds.getEast());\n\n        return new Polyline([leftLL, rightLL], this.lineStyle);\n    }\n\n    buildLabel(axis: 'gridlabel-horiz' | 'gridlabel-vert', val: number) {\n        const bounds = this._map.getBounds().pad(-0.003);\n        let latLng: LatLng;\n        if (axis == 'gridlabel-horiz') {\n            latLng = new LatLng(bounds.getNorth(), val);\n        } else {\n            latLng = new LatLng(val, bounds.getWest());\n        }\n\n        return marker(latLng, {\n            interactive: false,\n            icon: divIcon({\n                iconSize: [0, 0],\n                className: 'leaflet-grid-label',\n                html: '<div class=\"' + axis + '\">' + val + '&#8239;Â°</div>'\n            })\n        });\n    }\n\n    /**\n     * Rounds the given number to a fixed number of decimals in order to avoid floating point inaccuracies\n     * (for example to make 0.1 + 0.2 = 0.3 instead of 0.30000000000000004).\n     */\n    static fixFloatingPoint(number: number): number {\n        return AutoGraticule.round(number, 12);\n    }\n\n    /**\n     * Rounds the given number to the given number of decimals.\n     */\n    static round(number: number, digits: number) {\n        const fac = Math.pow(10, digits);\n        return Math.round(number*fac)/fac;\n    }\n\n    /**\n     * Given the distance between two coordinates, floors this distance to 90, 60, 45, 30 or\n     * 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01, ...\n     * This will define the distance between two grid lines.\n     * @param variableDistance This should be true when the distance between the grid lines will be variable, that is for the latitude\n     *     lines (because in Meractor projection the distance between two latitutes gets larger towards the poles, but the distance\n     *     between two longitudes is constant throughout the globe).\n     *     For constant distance lines (longitude), a line should be shown for every coordinate dividable by the result of this\n     *     function. For example, if the result is 45, a line should be shown for longitudes -180, -135, -90, -45, 0, 45, 90, 135, 180.\n     *     For variable distance lines (latitude), a line should be shown for coordinates dividable by a result of this function, but\n     *     not for every single coordinate but only those that have a minimum distance towards their neighbour coordinate line. For\n     *     variable distance lines, the maximum number returned by this function is 5, meaning at low zoom levels, all latitude lines\n     *     are dividable by 5 (but not every latitude dividable by 5 will get a line).\n     */\n    static getGridDivisor(number: number, variableDistance: boolean) {\n        if(number <= 0 || !isFinite(number))\n            throw new Error(\"Invalid number \" + number);\n        else {\n            if(variableDistance && number >= 5)\n                return 5;\n            if(number <= 10) {\n                let fac = 1;\n                while(number>1) { fac*=10; number/=10; }\n                while(number<=0.1) { fac/=10; number*=10; }\n\n                // Dist is now some number between 0.1 and 1, so we can round it conveniently and then multiply it again by fac to get back to the original dist\n\n                if(number == 0.1)\n                    return AutoGraticule.fixFloatingPoint(0.1*fac);\n                else if(number <= 0.2)\n                    return AutoGraticule.fixFloatingPoint(0.2*fac);\n                else if(number <= 0.5)\n                    return AutoGraticule.fixFloatingPoint(0.5*fac);\n                else\n                    return fac;\n            } else if(number <= 30)\n                return 30;\n            else if(number <= 45)\n                return 45;\n            else if(number <= 60)\n                return 60;\n            else\n                return 90;\n        }\n    }\n    // Backwards compatibility\n    static niceRound = AutoGraticule.getGridDivisor;\n\n    static bboxIntersect(bbox1: LatLngBounds | LatLngExpression[], bbox2: LatLngBounds | LatLngExpression[]) {\n        const bounds1 = bbox1 instanceof LatLngBounds ? bbox1 : latLngBounds(bbox1);\n        const bounds2 = bbox2 instanceof LatLngBounds ? bbox2 : latLngBounds(bbox2);\n        return latLngBounds([\n            [ Math.max(bounds1.getSouth(), bounds2.getSouth()), Math.max(bounds1.getWest(), bounds2.getWest())],\n            [ Math.min(bounds1.getNorth(), bounds2.getNorth()), Math.min(bounds1.getEast(), bounds2.getEast())]\n        ]);\n    }\n}\n"],"names":["LayerGroup","Util","divisor","LatLng","Polyline","marker","divIcon","LatLngBounds","latLngBounds"],"mappings":"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"}